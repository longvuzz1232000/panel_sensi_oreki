<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    
    <!-- Viewport t·ªëi ∆∞u cho mobile + full-screen -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <!-- Full-screen khi th√™m v√†o Home Screen (·∫©n to√†n b·ªô UI Safari) -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="mobile-web-app-capable" content="yes">
    
    <!-- T√™n hi·ªÉn th·ªã d∆∞·ªõi icon -->
    <meta name="apple-mobile-web-app-title" content="Oreki_Veritified">
    
    <!-- Icon (upload file icon.png 192x192 PNG c√πng th∆∞ m·ª•c n·∫øu c√≥) -->
    <link rel="apple-touch-icon" href="icon.png">
    
    <!-- Manifest ƒë·ªÉ tƒÉng kh·∫£ nƒÉng standalone/fullscreen -->
    <link rel="manifest" href="manifest.json">
    
    <!-- Theme color kh·ªõp n·ªÅn -->
    <meta name="theme-color" content="#050505">
    
    <title>Oreki_Veritified</title>
    
    <style>
        :root {
            --bg-color: #050505;
            --fg-color: #00ff00;
            --accent-color: #111111;
            --input-bg: #222222;
            --btn-bg: #003300;
            --btn-hover: #004d00;
            --btn-active: #006600;
            --danger-bg: #660000;
        }

        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
        }

        body {
            color: var(--fg-color);
            font-family: "Consolas", monospace;
            display: flex;
            justify-content: center;
            align-items: stretch;
            box-sizing: border-box;
        }

        .container {
            width: 100%;
            max-width: 650px;
            height: 100%;
            padding: 
                env(safe-area-inset-top) 20px 
                env(safe-area-inset-bottom) 20px;
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
            display: flex;
            flex-direction: column;
            gap: 15px;
            box-sizing: border-box;
            overflow-y: auto; /* Cho ph√©p scroll n·∫øu n·ªôi dung d√†i */
        }

        /* Rainbow Header */
        .header {
            font-size: 28px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 5px;
            display: flex;
            justify-content: center;
            gap: 2px;
            flex-wrap: wrap;
        }
        .char { display: inline-block; }

        .sub-header {
            text-align: center;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 20px;
        }

        /* Input Frame */
        .input-frame {
            background-color: var(--accent-color);
            border: 2px solid #333;
            padding: 15px;
            border-radius: 4px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }

        input[type="text"] {
            width: 100%;
            background-color: var(--input-bg);
            border: 1px solid #444;
            color: white;
            padding: 8px;
            font-family: "Consolas", monospace;
            font-size: 16px;
            box-sizing: border-box;
            margin-bottom: 15px;
        }
        input[type="text"]:focus {
            outline: 1px solid var(--fg-color);
        }

        /* Toggles */
        .mode-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            border-bottom: 1px solid #222;
        }
        .mode-row:last-child { border-bottom: none; }

        .switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 22px;
        }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #444;
            transition: .4s;
            border-radius: 22px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider { background-color: var(--fg-color); }
        input:checked + .slider:before { transform: translateX(22px); }

        /* Button */
        button {
            background-color: var(--btn-bg);
            color: var(--fg-color);
            border: 1px solid var(--fg-color);
            padding: 15px;
            font-family: "Consolas", monospace;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: 0.2s;
            width: 100%;
        }
        button:hover { background-color: var(--btn-hover); }
        button:active { background-color: var(--btn-active); color: white; }
        button:disabled { background-color: var(--danger-bg); color: #ffcccc; cursor: not-allowed; border-color: red; }

        /* Output */
        .output-frame {
            background-color: var(--accent-color);
            border: 2px solid #333;
            padding: 5px;
            flex-grow: 1;
            min-height: 300px;
        }
        textarea {
            width: 100%;
            height: 100%;
            min-height: 400px;
            background-color: #000;
            color: var(--fg-color);
            border: none;
            font-family: "Consolas", monospace;
            font-size: 14px;
            resize: none;
            padding: 10px;
            box-sizing: border-box;
        }
        textarea:focus { outline: none; }

        .status-bar {
            font-size: 12px;
            margin-top: 5px;
            color: var(--fg-color);
        }

        /* Loading Overlay */
        #loading-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            z-index: 9999;
            display: none;
        }
        .container.blurred {
            filter: blur(5px);
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Responsive Design for Mobile */
        @media (max-width: 680px) {
            .header {
                font-size: 22px;
            }
            .sub-header {
                font-size: 14px;
            }
            textarea {
                min-height: 300px;
                font-size: 12px;
            }
            button {
                padding: 12px;
            }
            .container {
                padding: 
                    env(safe-area-inset-top) 15px 
                    env(safe-area-inset-bottom) 15px;
            }
        }
    </style>
</head>
<body>

<div class="container">
    <div class="header" id="rainbow-header">
        <!-- JS will inject spans here -->
    </div>
    <div class="sub-header">üôà Mua file ib zalo 0336514635 üôà</div>

    <div class="input-frame">
        <label>T√™n thi·∫øt b·ªã (VD: Samsung S23 Ultra; iPhone 11; Redmi Note 11;...):</label>
        <input type="text" id="device-input" placeholder="Nh·∫≠p t√™n m√°y...">

        <label style="margin-top: 10px;">Ch·ªçn ch·ª©c nƒÉng:</label>
        <div id="modes-container">
            <!-- JS will inject modes here -->
        </div>
    </div>

    <button id="analyze-btn">>>> K√çCH HO·∫†T AI PH√ÇN T√çCH <<<</button>

    <div class="output-frame">
        <textarea id="result-text" readonly></textarea>
    </div>

    <div class="status-bar" id="status-bar">System Ready. Waiting for input...</div>
</div>

<div id="loading-overlay">
    <canvas id="loading-canvas"></canvas>
</div>

<script>
document.addEventListener("DOMContentLoaded", () => {
    // --- CONFIGURATION ---
    const MODES = [
        { text: "Nh·∫π T√¢m (Sensitivity)", id: "light" },
        { text: "Fix Rung (Fix Vibrate)", id: "recoil" },
        { text: "Gi·∫£m l·ªë (Reduce Overshoot)", id: "overshoot" },
        { text: "·ªîn ƒê·ªãnh (Stability)", id: "stable" },
        { text: "One Shot (Shotgun/Sniper)", id: "oneshot" },
        { text: "T·ªëi ∆∞u FPS (Buff Smooth)", id: "fps" },
        { text: "ƒê·ªì h·ªça Max (Check Graphics)", id: "graphics" }
    ];

    const VALID_BRANDS = ["iphone", "ipad", "samsung", "galaxy", "oppo", "vivo", "xiaomi", "redmi", "realme", "vsmart", "poco", "infinix", "tecno", "asus", "rog", "nubia", "sony", "lg", "google", "pixel", "huawei", "honor", "oneplus", "zte", "lenovo", "motorola", "nokia", "htc", "itel"];

    // --- SEEDED RANDOM CLASS ---
    class SeededRandom {
        constructor(seedStr) {
            this.seed = 0;
            for (let i = 0; i < seedStr.length; i++) {
                this.seed += seedStr.charCodeAt(i);
            }
        }
        
        next() {
            this.seed = (this.seed * 9301 + 49297) % 233280;
            return this.seed / 233280;
        }

        choice(arr) {
            return arr[Math.floor(this.next() * arr.length)];
        }

        randint(min, max) {
            return Math.floor(this.next() * (max - min + 1)) + min;
        }
    }

    // --- UI INITIALIZATION ---
    const headerText = "[ Oreki_Veritified ]";
    const headerEl = document.getElementById('rainbow-header');
    const headerChars = [];
    let headerHue = 0.0;

    for (let char of headerText) {
        let span = document.createElement('span');
        span.textContent = char === ' ' ? '\u00A0' : char;
        span.className = 'char';
        headerEl.appendChild(span);
        headerChars.push(span);
    }

    function animateHeader() {
        headerChars.forEach((span, i) => {
            let h = (headerHue - (i * 0.03)) % 1.0;
            if (h < 0) h += 1.0;
            let s = 1.0, v = 1.0;
            let r, g, b, i_h, f, p, q, t;
            i_h = Math.floor(h * 6);
            f = h * 6 - i_h;
            p = v * (1 - s);
            q = v * (1 - f * s);
            t = v * (1 - (1 - f) * s);
            switch (i_h % 6) {
                case 0: r = v; g = t; b = p; break;
                case 1: r = q; g = v; b = p; break;
                case 2: r = p; g = v; b = t; break;
                case 3: r = p; g = q; b = v; break;
                case 4: r = t; g = p; b = v; break;
                case 5: r = v; g = p; b = q; break;
            }
            span.style.color = `rgb(${Math.round(r*255)}, ${Math.round(g*255)}, ${Math.round(b*255)})`;
        });
        headerHue += 0.01;
        if (headerHue > 1.0) headerHue -= 1.0;
        requestAnimationFrame(animateHeader);
    }
    animateHeader();

    const modesContainer = document.getElementById('modes-container');
    MODES.forEach(mode => {
        const div = document.createElement('div');
        div.className = 'mode-row';
        div.innerHTML = `
            <span>${mode.text}</span>
            <label class="switch">
                <input type="checkbox" id="chk-${mode.id}">
                <span class="slider"></span>
            </label>
        `;
        modesContainer.appendChild(div);
    });

    // --- LOADING SCREEN ---
    const canvas = document.getElementById('loading-canvas');
    const ctx = canvas.getContext('2d');
    let animationId;
    let loadingProgress = 0;
    
    let globeLines = [];
    let globePoints = [];
    let globeAngle = 0.0;
    const globeRadius = 110;

    function initGlobeData() {
        globeLines = [];
        globePoints = [];
        
        for (let lon = 0; lon < 360; lon += 15) {
            let line = [];
            for (let lat = -90; lat <= 90; lat += 5) {
                let phi = lat * Math.PI / 180;
                let theta = lon * Math.PI / 180;
                line.push({
                    x: globeRadius * Math.cos(phi) * Math.cos(theta),
                    y: globeRadius * Math.sin(phi),
                    z: globeRadius * Math.cos(phi) * Math.sin(theta)
                });
            }
            globeLines.push(line);
        }
        for (let lat = -60; lat <= 60; lat += 20) {
            let line = [];
            for (let lon = 0; lon <= 360; lon += 5) {
                let phi = lat * Math.PI / 180;
                let theta = lon * Math.PI / 180;
                line.push({
                    x: globeRadius * Math.cos(phi) * Math.cos(theta),
                    y: globeRadius * Math.sin(phi),
                    z: globeRadius * Math.cos(phi) * Math.sin(theta)
                });
            }
            globeLines.push(line);
        }

        const continents = [
            {lat: 45, lon: -100, rad: 30},
            {lat: -20, lon: -60, rad: 25},
            {lat: 50, lon: 10, rad: 20},
            {lat: 10, lon: 20, rad: 30},
            {lat: 40, lon: 90, rad: 40},
            {lat: -25, lon: 135, rad: 20}
        ];
        continents.forEach(c => {
            for(let i=0; i<120; i++) {
                let lat = c.lat + (Math.random() * c.rad * 2 - c.rad);
                let lon = c.lon + (Math.random() * c.rad * 2 - c.rad);
                let phi = lat * Math.PI / 180;
                let theta = lon * Math.PI / 180;
                globePoints.push({
                    x: globeRadius * Math.cos(phi) * Math.cos(theta),
                    y: globeRadius * Math.sin(phi),
                    z: globeRadius * Math.cos(phi) * Math.sin(theta)
                });
            }
        });
    }

    let matrixStreams = [];
    
    function setupMatrix() {
        matrixStreams = [];
        const fontSize = 12;
        const columns = Math.floor(canvas.width / fontSize);
        for(let i=0; i<columns; i++) {
            matrixStreams.push({
                x: i * fontSize,
                y: Math.random() * -500,
                speed: Math.floor(Math.random() * 10) + 15,
                length: Math.floor(Math.random() * 20) + 10,
                chars: Array(30).fill(0).map(() => Math.random() > 0.5 ? '1' : '0')
            });
        }
    }

    function animateLoading() {
        if (canvas.width !== window.innerWidth || canvas.height !== window.innerHeight) {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            setupMatrix();
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const fontSize = 12;
        ctx.font = "bold 12px Consolas";

        matrixStreams.forEach(stream => {
            stream.y += stream.speed;
            if (stream.y - stream.length * fontSize > canvas.height) {
                stream.y = Math.random() * -200;
            }
            
            for(let i=0; i<stream.length; i++) {
                let charY = stream.y - i * fontSize;
                if (charY > 0 && charY < canvas.height) {
                    if (i === 0) {
                        ctx.fillStyle = "#00ff00";
                    } else {
                        ctx.fillStyle = "#003300";
                    }
                    if (Math.random() > 0.95) stream.chars[i] = stream.chars[i] === '1' ? '0' : '1';
                    ctx.fillText(stream.chars[i], stream.x, charY);
                }
            }
        });

        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        globeAngle += 0.02;
        const cosA = Math.cos(globeAngle);
        const sinA = Math.sin(globeAngle);

        ctx.lineWidth = 1;
        ctx.strokeStyle = "#003300";

        globeLines.forEach(line => {
            ctx.beginPath();
            let first = true;
            line.forEach(p => {
                let rx = p.x * cosA - p.z * sinA;
                let rz = p.x * sinA + p.z * cosA;
                if (first) {
                    ctx.moveTo(cx + rx, cy + p.y);
                    first = false;
                } else {
                    ctx.lineTo(cx + rx, cy + p.y);
                }
            });
            ctx.stroke();
        });

        ctx.fillStyle = "#00ff00";
        globePoints.forEach(p => {
            let rx = p.x * cosA - p.z * sinA;
            let rz = p.x * sinA + p.z * cosA;
            if (rz > 0) {
                ctx.beginPath();
                ctx.arc(cx + rx, cy + p.y, 1, 0, Math.PI * 2);
                ctx.fill();
            }
        });

        const barWidth = 300;
        const barHeight = 10;
        const barX = cx - barWidth / 2;
        const barY = cy + 140;

        ctx.strokeStyle = "#00ff00";
        ctx.strokeRect(barX, barY, barWidth, barHeight);
        
        const fillWidth = (loadingProgress / 100) * barWidth;
        ctx.fillStyle = "#00ff00";
        ctx.fillRect(barX, barY, fillWidth, barHeight);

        ctx.textAlign = "center";
        ctx.fillText(`ANALYZING DATA... ${Math.min(100, Math.floor(loadingProgress))}%`, cx, barY + 25);
        ctx.textAlign = "start";

        animationId = requestAnimationFrame(animateLoading);
    }

    // --- MAIN LOGIC ---
    async function startAnalysis() {
        const deviceName = document.getElementById('device-input').value.trim();
        
        if (!deviceName) {
            alert("Vui l√≤ng nh·∫≠p t√™n thi·∫øt b·ªã!");
            return;
        }

        const isBrandValid = VALID_BRANDS.some(brand => deviceName.toLowerCase().includes(brand));
        if (!isBrandValid) {
            alert("Thi·∫øt b·ªã kh√¥ng ƒë∆∞·ª£c nh·∫≠n di·ªán ho·∫∑c kh√¥ng ph·ªï bi·∫øn tr√™n th·ªã tr∆∞·ªùng!\nVui l√≤ng nh·∫≠p ƒë√∫ng t√™n d√≤ng m√°y (VD: Samsung S23, iPhone 11...)");
            return;
        }

        const btn = document.getElementById('analyze-btn');
        btn.disabled = true;
        btn.style.backgroundColor = "#660000";
        btn.style.color = "#ff0000";
        document.getElementById('result-text').value = "";

        const overlay = document.getElementById('loading-overlay');
        overlay.style.display = 'block';
        document.querySelector('.container').classList.add('blurred');
        initGlobeData();
        setupMatrix();
        loadingProgress = 0;
        animateLoading();

        for (let i = 1; i <= 100; i++) {
            loadingProgress = i;
            let delay = 15;
            if (i >= 40) delay = 25;
            if (i >= 80) delay = 40;
            await new Promise(r => setTimeout(r, delay));
        }
        await new Promise(r => setTimeout(r, 300));

        cancelAnimationFrame(animationId);
        overlay.style.display = 'none';
        document.querySelector('.container').classList.remove('blurred');

        const selectedModes = MODES.filter(m => document.getElementById(`chk-${m.id}`).checked).map(m => m.id);
        if (selectedModes.length === 0) selectedModes.push("stable");

        const config = calculateSensitivity(deviceName, selectedModes);
        displayResult(config);

        document.getElementById('status-bar').textContent = "Analysis Complete.";
        btn.disabled = false;
        btn.style.backgroundColor = "";
        btn.style.color = "";
    }

    function calculateSensitivity(device, modes) {
        const rng = new SeededRandom(device.toLowerCase());
        
        const isIos = ['iphone', 'ipad', 'ios'].some(x => device.toLowerCase().includes(x));
        const isHighEnd = ['pro', 'ultra', 'plus', 'max', 's2', 'rog', 'black shark'].some(x => device.toLowerCase().includes(x));

        let baseDpi, dpiLabel;
        if (isIos) {
            baseDpi = rng.choice([31, 120]);
            dpiLabel = "Gi√° tr·ªã con tr·ªè tr∆∞·ª£t (Sliding Cursor)";
        } else {
            if (modes.includes("oneshot") || modes.includes("light")) {
                baseDpi = rng.choice([581, 600, 720, 800]);
            } else if (modes.includes("recoil")) {
                baseDpi = rng.choice([411, 440, 480]);
            } else {
                baseDpi = rng.choice([480, 500, 550]);
            }
            dpiLabel = "DPI (ƒê·ªô r·ªông t·ªëi thi·ªÉu)";
        }

        let sensGeneral = rng.randint(185, 200);
        let sensRedDot = rng.randint(175, 195);
        let sens2x = rng.randint(165, 185);
        let sens4x = rng.randint(155, 175);
        let sensSniper = rng.randint(60, 80);
        let sensLook = rng.randint(120, 160);
        let buttonSize = rng.randint(45, 55);

        let notes = [];
        notes.push(`AI nh·∫≠n di·ªán thi·∫øt b·ªã: ${isHighEnd ? 'High-End' : 'Standard'}. T·ªëi ∆∞u h√≥a ƒë·ªô tr·ªÖ c·∫£m ·ª©ng.`);

        let graphicsSetting = "Th·∫•p (Smooth)";
        let fpsSetting = "Cao (High)";
        let shadows = "T·∫Øt (Off)";

        if (modes.includes("light")) {
            sensGeneral = 200;
            sensRedDot = rng.randint(190, 200);
            buttonSize = rng.randint(38, 45);
            notes.push("C√¥ng th·ª©c 'Light Touch' (Ruok Style): T·ªëi ƒëa ƒë·ªô nh·∫°y ƒë·ªÉ vu·ªët nh·∫π l√† l√™n ƒë·∫ßu.");
        }

        if (modes.includes("recoil")) {
            sens2x = rng.randint(130, 150);
            sens4x = rng.randint(110, 130);
            buttonSize = rng.randint(55, 62);
            notes.push("C√¥ng th·ª©c 'Anti-Recoil': Gi·∫£m ƒë·ªô nh·∫°y Scope, tƒÉng k√≠ch th∆∞·ªõc n√∫t b·∫Øn ƒë·ªÉ gh√¨m t√¢m.");
        }

        if (modes.includes("overshoot")) {
            sensGeneral = Math.floor(sensGeneral * 0.95);
            sensRedDot = Math.floor(sensRedDot * 0.92);
            notes.push("AI tinh ch·ªânh: Gi·∫£m nh·∫π Red Dot (5-8%) ƒë·ªÉ tr√°nh t√¢m bay qua ƒë·∫ßu ƒë·ªãch.");
        }

        if (modes.includes("oneshot")) {
            sensGeneral = 200; sensRedDot = 200; sens2x = 200; sens4x = 200; sensLook = 200;
            sensSniper = rng.randint(100, 150);
            buttonSize = rng.randint(35, 42);
            notes.push("C√¥ng th·ª©c 'One Shot' (Raistar Style): Full ƒë·ªô nh·∫°y, DPI cao ƒë·ªÉ Flick Shot.");
        }

        if (modes.includes("fps")) {
            graphicsSetting = "Th·∫•p (Smooth)";
            fpsSetting = "Cao/Ultra (High)";
            shadows = "T·∫Øt (Off)";
            notes.push("T·ªëi ∆∞u h√≥a: ∆Øu ti√™n FPS cao nh·∫•t ƒë·ªÉ gi·∫£m ƒë·ªô tr·ªÖ input.");
        }

        if (modes.includes("graphics")) {
            graphicsSetting = "Max (Ultra)";
            fpsSetting = "Cao (High)";
            shadows = "B·∫≠t (On)";
            notes.push("T·ªëi ∆∞u h√≥a: B·∫≠t max ƒë·ªì h·ªça (H·ªó tr·ª£ nh√¨n ƒë·ªãch xa).");
        }

        if (modes.includes("stable") && modes.length === 1) {
            notes.push("C·∫•u h√¨nh c√¢n b·∫±ng (Standard Competitive).");
        }

        const clamp = (num, min, max) => Math.min(Math.max(num, min), max);
        sensGeneral = clamp(sensGeneral, 0, 200);
        sensRedDot = clamp(sensRedDot, 0, 200);
        sens2x = clamp(sens2x, 0, 200);
        sens4x = clamp(sens4x, 0, 200);
        sensSniper = clamp(sensSniper, 0, 200);
        sensLook = clamp(sensLook, 0, 200);

        let speedScore = rng.randint(65, 80);
        let aimScore = rng.randint(65, 80);
        let stabilityScore = rng.randint(65, 80);

        if (modes.includes("light")) { speedScore += 15; stabilityScore -= 10; }
        if (modes.includes("oneshot")) { speedScore += 20; aimScore -= 5; stabilityScore -= 15; }
        if (modes.includes("recoil")) { stabilityScore += 20; aimScore += 10; speedScore -= 10; }
        if (modes.includes("stable")) { stabilityScore += 15; aimScore += 5; }
        if (modes.includes("overshoot")) { aimScore += 15; speedScore -= 5; }
        if (modes.includes("fps")) { speedScore += 5; }

        return {
            device: device,
            modes: modes.join(", ").toUpperCase(),
            dpi: baseDpi,
            dpiLabel: dpiLabel,
            general: sensGeneral,
            redDot: sensRedDot,
            x2: sens2x,
            x4: sens4x,
            sniper: sensSniper,
            look: sensLook,
            button: buttonSize,
            graphics: graphicsSetting,
            fps: fpsSetting,
            shadows: shadows,
            note: notes.join(" + "),
            speed: clamp(speedScore, 10, 100),
            aim: clamp(aimScore, 10, 100),
            stability: clamp(stabilityScore, 10, 100)
        };
    }

    function displayResult(config) {
        function drawBar(val) {
            const filled = Math.floor(val / 10);
            return "‚ñ†".repeat(filled) + "‚ñ°".repeat(10 - filled);
        }

        const output = `
================================================
   K·∫æT QU·∫¢ T·ªêI ∆ØU H√ìA: ${config.device.toUpperCase()}
================================================

[ TH√îNG S·ªê H·ªÜ TH·ªêNG ]
> Ch·∫ø ƒë·ªô: ${config.modes}
> ${config.dpiLabel}: ${config.dpi}
> T·ªëc ƒë·ªô con tr·ªè: M·ª©c 7 (M·∫∑c ƒë·ªãnh)

[ ƒê·ªò NH·∫†Y FREE FIRE MAX (0-200) ]
> Nh√¨n xung quanh:  ${config.general}
> Red Dot:          ${config.redDot}
> ·ªêng ng·∫Øm 2x:      ${config.x2}
> ·ªêng ng·∫Øm 4x:      ${config.x4}
> ·ªêng ng·∫Øm Sniper:  ${config.sniper}
> Nh√¨n:             ${config.look}

[ ƒê·ªí H·ªåA & FPS ]
> ƒê·ªì h·ªça:           ${config.graphics}
> FPS:              ${config.fps}
> B√≥ng ƒë·ªï:          ${config.shadows}

[ HUD CONTROL ]
> K√≠ch th∆∞·ªõc n√∫t b·∫Øn: ${config.button}%
> V·ªã tr√≠ n√∫t b·∫Øn:     K√©o th·∫•p xu·ªëng d∆∞·ªõi 10%

[ BI·ªÇU ƒê·ªí CH·ªà S·ªê (RADAR) ]
SPEED     : ${drawBar(config.speed)} (${config.speed})
AIM       : ${drawBar(config.aim)} (${config.aim})
STABILITY : ${drawBar(config.stability)} (${config.stability})

[ L·ªúI KHUY√äN T·ª™ OREKI ]
> ${config.note}

Mua file ib zalo 0336514635
================================================
Generated by Oreki_Veritified
`;
        document.getElementById('result-text').value = output.trim();
    }

    document.getElementById('analyze-btn').addEventListener('click', startAnalysis);
});
</script>

</body>
</html>